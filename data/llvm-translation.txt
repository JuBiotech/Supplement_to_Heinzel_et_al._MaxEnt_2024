User
Hey I am currently updating my matlab scripts to use cobrapy instead of cobra meaning I have to translate matlab expressions to python.

Here are two examples I translated manually:

input:
M=changeRxnBounds(M,'EX_o2_e',-30,'l');
output: 
model.reactions.get_by_id("EX_o2_e").lower_bound = -30
input:
M=changeRxnBounds(M,'PI_t_NA',0,'b');
output: 
model.reactions.get_by_id("PI_t_NA").lower_bound = 0
model.reactions.get_by_id("PI_t_NA").upper_bound = 0

If I give you a list of further expressions, can you help me translate them?
ChatGPT

Of course, I'd be happy to help you translate your MATLAB expressions to Python using cobrapy. Feel free to provide the list of expressions you need help with, and I'll assist you in translating them.
User
Here is the first matlab expression:
M=changeRxnBounds(M,'PI_t_ATP',0,'b');
ChatGPT

Here's the Python equivalent using cobrapy:

python

model.reactions.get_by_id("PI_t_ATP").lower_bound = 0
model.reactions.get_by_id("PI_t_ATP").upper_bound = 0

This sets both the lower and upper bounds of the reaction "PI_t_ATP" to 0.
User
thanks. Here are the rest of the expressions:

M=changeRxnBounds(M,'aceA',0,'b');
M=changeRxnBounds(M,'aceB',0,'b');
M=changeRxnBounds(M,'NH3_t_H',0,'b');
M=changeRxnBounds(M,'UREA_d',0,'b');
M=changeRxnBounds(M,'UREA_t_H',0,'b');
M=changeRxnBounds(M,'SUC_t_H',0,'b');
M=changeRxnBounds(M,'FUM_t_H',0,'b');
M=changeRxnBounds(M,'MAL_t_H',0,'b');
M=changeRxnBounds(M,'NA_t_H',0,'b');
M=changeRxnBounds(M,'LAC_L_t_H',0,'b');
M=changeRxnBounds(M,'LYS_t_H',0,'b');
M=changeRxnBounds(M,'AC_t_H',0,'b');
M=changeRxnBounds(M,'NO3_t_H',0,'b');
M=changeRxnBounds(M,'GLU_t_H',0,'b');
M=changeRxnBounds(M,'THR_t_H',0,'b');
M=changeRxnBounds(M,'nagB',0,'l');
M=changeRxnBounds(M,'PPI_d',0,'b');
M=changeRxnBounds(M,'tkt_1',0,'l');
M=changeRxnBounds(M,'tkt_2',0,'l');
M=changeRxnBounds(M,'tal',0,'l');
M=changeRxnBounds(M,'glgC',0,'b');
M=changeRxnBounds(M,'CO2_d',0,'l');
M=changeRxnBounds(M,'aspA',0,'l');
M=changeRxnBounds(M,'aspB',0,'l');
M=changeRxnBounds(M,'leakage',-50,'l');
M=changeRxnBounds(M,'leakage',50,'u');
M=changeRxnBounds(M,'folD2',-1,'l');
M=changeRxnBounds(M,'metF',-1,'l');
M=changeRxnBounds(M,'folD2',1,'u');
M=changeRxnBounds(M,'metF',1,'u');
M=changeRxnBounds(M,'pps',0,'b');
M=changeRxnBounds(M,'glpD',0,'b');
M=changeRxnBounds(M,'putA',0,'b');
M=changeRxnBounds(M,'tpiA',-100,'l');
M=changeRxnBounds(M,'aceA',-100,'l');
M=changeRxnBounds(M,'aceA',100,'u');
M=changeRxnBounds(M,'aceB',100,'u');
M=changeRxnBounds(M,'quiC',0,'b');
M=changeRxnBounds(M,'PROTEIN_b',0,'b');
M=changeRxnBounds(M,'DNA_a',0,'b');
ChatGPT

Here are the translations of the provided MATLAB expressions to Python using cobrapy:

python

# Setting both lower and upper bounds to 0
model.reactions.get_by_id("aceA").lower_bound = 0
model.reactions.get_by_id("aceA").upper_bound = 0

model.reactions.get_by_id("aceB").lower_bound = 0
model.reactions.get_by_id("aceB").upper_bound = 0

model.reactions.get_by_id("NH3_t_H").lower_bound = 0
model.reactions.get_by_id("NH3_t_H").upper_bound = 0

model.reactions.get_by_id("UREA_d").lower_bound = 0
model.reactions.get_by_id("UREA_d").upper_bound = 0

model.reactions.get_by_id("UREA_t_H").lower_bound = 0
model.reactions.get_by_id("UREA_t_H").upper_bound = 0

model.reactions.get_by_id("SUC_t_H").lower_bound = 0
model.reactions.get_by_id("SUC_t_H").upper_bound = 0

model.reactions.get_by_id("FUM_t_H").lower_bound = 0
model.reactions.get_by_id("FUM_t_H").upper_bound = 0

model.reactions.get_by_id("MAL_t_H").lower_bound = 0
model.reactions.get_by_id("MAL_t_H").upper_bound = 0

model.reactions.get_by_id("NA_t_H").lower_bound = 0
model.reactions.get_by_id("NA_t_H").upper_bound = 0

model.reactions.get_by_id("LAC_L_t_H").lower_bound = 0
model.reactions.get_by_id("LAC_L_t_H").upper_bound = 0

model.reactions.get_by_id("LYS_t_H").lower_bound = 0
model.reactions.get_by_id("LYS_t_H").upper_bound = 0

model.reactions.get_by_id("AC_t_H").lower_bound = 0
model.reactions.get_by_id("AC_t_H").upper_bound = 0

model.reactions.get_by_id("NO3_t_H").lower_bound = 0
model.reactions.get_by_id("NO3_t_H").upper_bound = 0

model.reactions.get_by_id("GLU_t_H").lower_bound = 0
model.reactions.get_by_id("GLU_t_H").upper_bound = 0

model.reactions.get_by_id("THR_t_H").lower_bound = 0
model.reactions.get_by_id("THR_t_H").upper_bound = 0

model.reactions.get_by_id("nagB").lower_bound = 0
model.reactions.get_by_id("nagB").upper_bound = 0

model.reactions.get_by_id("PPI_d").lower_bound = 0
model.reactions.get_by_id("PPI_d").upper_bound = 0

model.reactions.get_by_id("tkt_1").lower_bound = 0
model.reactions.get_by_id("tkt_1").upper_bound = 0

model.reactions.get_by_id("tkt_2").lower_bound = 0
model.reactions.get_by_id("tkt_2").upper_bound = 0

model.reactions.get_by_id("tal").lower_bound = 0
model.reactions.get_by_id("tal").upper_bound = 0

model.reactions.get_by_id("glgC").lower_bound = 0
model.reactions.get_by_id("glgC").upper_bound = 0

model.reactions.get_by_id("CO2_d").lower_bound = 0
model.reactions.get_by_id("CO2_d").upper_bound = 0

model.reactions.get_by_id("aspA").lower_bound = 0
model.reactions.get_by_id("aspA").upper_bound = 0

model.reactions.get_by_id("aspB").lower_bound = 0
model.reactions.get_by_id("aspB").upper_bound = 0

# Setting lower bound to -50
model.reactions.get_by_id("leakage").lower_bound = -50

# Setting upper bound to 50
model.reactions.get_by_id("leakage").upper_bound = 50

# Setting lower bounds to -1
model.reactions.get_by_id("folD2").lower_bound = -1
model.reactions.get_by_id("metF").lower_bound = -1

# Setting upper bounds to 1
model.reactions.get_by_id("folD2").upper_bound = 1
model.reactions.get_by_id("metF").upper_bound = 1

model.reactions.get_by_id("pps").lower_bound = 0
model.reactions.get_by_id("pps").upper_bound = 0

model.reactions.get_by_id("glpD").lower_bound = 0
model.reactions.get_by_id("glpD").upper_bound = 0

model.reactions.get_by_id("putA").lower_bound = 0
model.reactions.get_by_id("putA").upper_bound = 0

# Setting lower bound to -100
model.reactions.get_by_id("tpiA").lower_bound = -100

# Setting lower bound to -100
model.reactions.get_by_id("aceA").lower_bound = -100

# Setting upper bound to 100
model.reactions.get_by_id("aceA").upper_bound = 100

# Setting upper bound to 100
model.reactions.get_by_id("aceB").upper_bound = 100

model.reactions.get_by_id("quiC").lower_bound = 0
model.reactions.get_by_id("quiC").upper_bound = 0

model.reactions.get_by_id("PROTEIN_b").lower_bound = 0
model.reactions.get_by_id("PROTEIN_b").upper_bound = 0

model.reactions.get_by_id("DNA_a").lower_bound = 0
model.reactions.get_by_id("DNA_a").upper_bound = 0

These translations set the bounds of the specified reactions in cobrapy according to the given MATLAB expressions.
User
that's perfect! Can you add the original expression as a python comment above the translated expression?
ChatGPT

Sure, here are the translations with the original MATLAB expressions added as comments above each Python expression:

python

# M=changeRxnBounds(M,'aceA',0,'b');
model.reactions.get_by_id("aceA").lower_bound = 0
model.reactions.get_by_id("aceA").upper_bound = 0

# M=changeRxnBounds(M,'aceB',0,'b');
model.reactions.get_by_id("aceB").lower_bound = 0
model.reactions.get_by_id("aceB").upper_bound = 0

# M=changeRxnBounds(M,'NH3_t_H',0,'b');
model.reactions.get_by_id("NH3_t_H").lower_bound = 0
model.reactions.get_by_id("NH3_t_H").upper_bound = 0

# M=changeRxnBounds(M,'UREA_d',0,'b');
model.reactions.get_by_id("UREA_d").lower_bound = 0
model.reactions.get_by_id("UREA_d").upper_bound = 0

# M=changeRxnBounds(M,'UREA_t_H',0,'b');
model.reactions.get_by_id("UREA_t_H").lower_bound = 0
model.reactions.get_by_id("UREA_t_H").upper_bound = 0

# M=changeRxnBounds(M,'SUC_t_H',0,'b');
model.reactions.get_by_id("SUC_t_H").lower_bound = 0
model.reactions.get_by_id("SUC_t_H").upper_bound = 0

# M=changeRxnBounds(M,'FUM_t_H',0,'b');
model.reactions.get_by_id("FUM_t_H").lower_bound = 0
model.reactions.get_by_id("FUM_t_H").upper_bound = 0

# M=changeRxnBounds(M,'MAL_t_H',0,'b');
model.reactions.get_by_id("MAL_t_H").lower_bound = 0
model.reactions.get_by_id("MAL_t_H").upper_bound = 0

# M=changeRxnBounds(M,'NA_t_H',0,'b');
model.reactions.get_by_id("NA_t_H").lower_bound = 0
model.reactions.get_by_id("NA_t_H").upper_bound = 0

# M=changeRxnBounds(M,'LAC_L_t_H',0,'b');
model.reactions.get_by_id("LAC_L_t_H").lower_bound = 0
model.reactions.get_by_id("LAC_L_t_H").upper_bound = 0

# M=changeRxnBounds(M,'LYS_t_H',0,'b');
model.reactions.get_by_id("LYS_t_H").lower_bound = 0
model.reactions.get_by_id("LYS_t_H").upper_bound = 0

# M=changeRxnBounds(M,'AC_t_H',0,'b');
model.reactions.get_by_id("AC_t_H").lower_bound = 0
model.reactions.get_by_id("AC_t_H").upper_bound = 0

# M=changeRxnBounds(M,'NO3_t_H',0,'b');
model.reactions.get_by_id("NO3_t_H").lower_bound = 0
model.reactions.get_by_id("NO3_t_H").upper_bound = 0

# M=changeRxnBounds(M,'GLU_t_H',0,'b');
model.reactions.get_by_id("GLU_t_H").lower_bound = 0
model.reactions.get_by_id("GLU_t_H").upper_bound = 0

# M=changeRxnBounds(M,'THR_t_H',0,'b');
model.reactions.get_by_id("THR_t_H").lower_bound = 0
model.reactions.get_by_id("THR_t_H").upper_bound = 0

# M=changeRxnBounds(M,'nagB',0,'l');
model.reactions.get_by_id("nagB").lower_bound = 0
model.reactions.get_by_id("nagB").upper_bound = 0

# M=changeRxnBounds(M,'PPI_d',0,'b');
model.reactions.get_by_id("PPI_d").lower_bound = 0
model.reactions.get_by_id("PPI_d").upper_bound = 0

# M=changeRxnBounds(M,'tkt_1',0,'l');
model.reactions.get_by_id("tkt_1").lower_bound = 0
model.reactions.get_by_id("tkt_1").upper_bound = 0

# M=changeRxnBounds(M,'tkt_2',0,'l');
model.reactions.get_by_id("tkt_2").lower_bound = 0
model.reactions.get_by_id("tkt_2").upper_bound = 0

# M=changeRxnBounds(M,'tal',0,'l');
model.reactions.get_by_id("tal").lower_bound = 0
model.reactions.get_by_id("tal").upper_bound = 0

# M=changeRxnBounds(M,'glgC',0,'b');
model.reactions.get_by_id("glgC").lower_bound = 0
model.reactions.get_by_id("glgC").upper_bound = 0

# M=changeRxnBounds(M,'CO2_d',0,'l');
model.reactions.get_by_id("CO2_d").lower_bound = 0
model.reactions.get_by_id("CO2_d").upper_bound = 0

# M=changeRxnBounds(M,'aspA',0,'l');
model.reactions.get_by_id("aspA").lower_bound = 0
model.reactions.get_by_id("aspA").upper_bound = 0

# M=changeRxnBounds(M,'aspB',0,'l');
model.reactions.get_by_id("aspB").lower_bound = 0
model.reactions.get_by_id("aspB").upper_bound = 0

# M=changeRxnBounds(M,'leakage',-50,'l');
model.reactions.get_by_id("leakage").lower_bound = -50

# M=changeRxnBounds(M,'leakage',50,'u');
model.reactions.get_by_id("leakage").upper_bound = 50

# M=changeRxnBounds(M,'folD2',-1,'l');
model.reactions.get_by_id("folD2").lower_bound = -1

# M=changeRxnBounds(M,'metF',-1,'l');
model.reactions.get_by_id("metF").lower_bound = -1

# M=changeRxnBounds(M,'folD2',1,'u');
model.reactions.get_by_id("folD2").upper_bound = 1

# M=changeRxnBounds(M,'metF',1,'u');
model.reactions.get_by_id("metF").upper_bound = 1

# M=changeRxnBounds(M,'pps',0,'b');
model.reactions.get_by_id("pps").lower_bound = 0
model.reactions.get_by_id("pps").upper_bound = 0

# M=changeRxnBounds(M,'glpD',0,'b');
model.reactions.get_by_id("glpD").lower_bound = 0
model.reactions.get_by_id("glpD").upper_bound = 0

# M=changeRxnBounds(M,'putA',0,'b');
model.reactions.get_by_id("putA").lower_bound = 0
model.reactions.get_by_id("putA").upper_bound = 0

# M=changeRxnBounds(M,'tpiA',-100,'l');
model.reactions.get_by_id("tpiA").lower_bound = -100

# M=changeRxnBounds(M,'aceA',-100,'l');
model.reactions.get_by_id("aceA").lower_bound = -100

# M=changeRxnBounds(M,'aceA',100,'u');
model.reactions.get_by_id("aceA").upper_bound = 100

# M=changeRxnBounds(M,'aceB',100,'u');
model.reactions.get_by_id("aceB").upper_bound = 100

# M=changeRxnBounds(M,'quiC',0,'b');
model.reactions.get_by_id("quiC").lower_bound = 0
model.reactions.get_by_id("quiC").upper_bound = 0

# M=changeRxnBounds(M,'PROTEIN_b',0,'b');
model.reactions.get_by_id("PROTEIN_b").lower_bound = 0
model.reactions.get_by_id("PROTEIN_b").upper_bound = 0

# M=changeRxnBounds(M,'DNA_a',0,'b');
model.reactions.get_by_id("DNA_a").lower_bound = 0
model.reactions.get_by_id("DNA_a").upper_bound = 0

Now, each translation is accompanied by its corresponding original MATLAB expression as a comment.
User
perfect. I need some more help understanding what the matlab script is doing. The parts you translated are clear, but in addition, it also does the following:

M=readCbModel('iEZ481_2024');clc
M.rxns=M.rxns';

[m,r]=size(M.S);



for i=1:r
    if(i<=m)
        if(strcmp(M.mets{i},'h[e]')==1),           ind(1)=i;
        elseif(strcmp(M.mets{i},'h[c]')==1),       ind(2)=i;
        elseif(strcmp(M.mets{i},'pi[c]')==1),      ind(3)=i;
        elseif(strcmp(M.mets{i},'atp[c]')==1),     ind(4)=i;
        elseif(strcmp(M.mets{i},'adp[c]')==1),     ind(5)=i;           
        end 
    end
   
    if(strcmp(M.rxns{i},'biomass_a')==1), Rkt(1)=i; end
end
M.S(ind(4),Rkt(1))=-(29.2+6.4);
M.S(ind(5),Rkt(1))=29.2+6.4;
M.S(ind(3),Rkt(1))=29.2+6.4;
M=changeRxnBounds(M,'mt',0,'b'); % [1.08,1.8] nomineller Wert 1.4
ChatGPT

Sure, let me break down what each part of the MATLAB script is doing:

    Reading a Constraint-Based Model (CBM): The script starts by reading a CBM from a file named 'iEZ481_2024' using the function readCbModel. This function reads the CBM and stores it in the variable M.

    Transpose of Reaction Names: After reading the model, the script transposes the reaction names stored in M.rxns using the transpose operator '. This likely converts a row vector to a column vector or vice versa, making it easier to work with later in the script.

    Obtaining Sizes of Stoichiometric Matrix: It calculates the size of the stoichiometric matrix M.S using the size function, storing the number of rows in m and the number of columns in r.

    Finding Indices of Specific Metabolites and Reactions: It loops through each reaction (r iterations) and checks if the metabolite associated with that reaction matches certain criteria (e.g., 'h[e]', 'h[c]', 'pi[c]', 'atp[c]', 'adp[c]'). If it matches, it stores the index of that metabolite in the variable ind. Similarly, it checks if the reaction name matches 'biomass_a' and stores its index in the variable Rkt.

    Adjusting Stoichiometric Coefficients: After identifying specific metabolites and the biomass reaction, the script modifies the stoichiometric coefficients of certain metabolites in the biomass reaction (Rkt(1)) in the stoichiometric matrix M.S. Specifically, it sets the stoichiometric coefficient of 'atp[c]' to -(29.2 + 6.4), 'adp[c]' to (29.2 + 6.4), and 'pi[c]' to (29.2 + 6.4). This seems to be a specific adjustment related to the biomass reaction.

    Changing Reaction Bounds: Finally, the script changes the bounds of the reaction 'mt' to 0 using the function changeRxnBounds, setting both lower and upper bounds to 0. This likely imposes a constraint on the flux of this reaction in the model.

Overall, this script seems to be performing preprocessing tasks on a constraint-based model, including adjusting stoichiometric coefficients and reaction bounds, possibly to prepare the model for further analysis or simulation.
User
that makes sense. Can you translate the matlab code to python also?
ChatGPT

Certainly! Here's the translation of the provided MATLAB code to Python using cobrapy:

python

import cobra

# Read the Constraint-Based Model (CBM)
M = cobra.io.read_sbml_model('iEZ481_2024.xml')  # Assuming the model is in SBML format

# Transpose reaction names
M_rxns_transposed = [rxn.id for rxn in M.reactions]

# Get the size of the stoichiometric matrix
m, r = M.S.shape

# Initialize lists to store indices of specific metabolites and reactions
ind = [None] * 5
Rkt = [None]

# Loop through each reaction
for i in range(r):
    # Check for specific metabolites and store their indices
    if i < m:
        if M.metabolites[i].id == 'h_e':
            ind[0] = i
        elif M.metabolites[i].id == 'h_c':
            ind[1] = i
        elif M.metabolites[i].id == 'pi_c':
            ind[2] = i
        elif M.metabolites[i].id == 'atp_c':
            ind[3] = i
        elif M.metabolites[i].id == 'adp_c':
            ind[4] = i
    
    # Check for the biomass reaction and store its index
    if M_rxns_transposed[i] == 'biomass_a':
        Rkt[0] = i

# Adjust stoichiometric coefficients
M.S[ind[3], Rkt[0]] = -(29.2 + 6.4)
M.S[ind[4], Rkt[0]] = 29.2 + 6.4
M.S[ind[2], Rkt[0]] = 29.2 + 6.4

# Change reaction bounds
M.reactions.get_by_id('mt').lower_bound = 0
M.reactions.get_by_id('mt').upper_bound = 0

This Python code performs the same operations as the provided MATLAB code, including reading the CBM, transposing reaction names, finding indices of specific metabolites and reactions, adjusting stoichiometric coefficients, and changing reaction bounds.
User
That's almost right. However, the Model object seems to have no attribute 'S'. Do you happen to know from the cobra docs what the API is to access the stoichiometric matrix?
ChatGPT

Yes, you're correct. In cobrapy, the stoichiometric matrix is typically accessed through the model.S attribute. However, the attribute S doesn't exist directly in the cobra.Model object. Instead, you can access the stoichiometric matrix indirectly through the model.metabolites and model.reactions attributes.

Here's how you can access the stoichiometric matrix in cobrapy:

python

# Initialize the stoichiometric matrix as a dictionary
S_dict = {}

# Populate the stoichiometric matrix dictionary
for reaction in model.reactions:
    for metabolite in reaction.metabolites:
        S_dict[(metabolite.id, reaction.id)] = reaction.metabolites[metabolite]

# Convert the dictionary to a pandas DataFrame for easier manipulation
import pandas as pd
S_df = pd.DataFrame(S_dict).fillna(0)

In this code:

    We initialize an empty dictionary S_dict to store the stoichiometric coefficients.
    We iterate through each reaction and metabolite in the model, and for each pair, we store the stoichiometric coefficient in the dictionary S_dict.
    Finally, we convert the dictionary to a pandas DataFrame S_df for easier manipulation.

With this approach, you can access the stoichiometric coefficients using S_df.loc[metabolite_id, reaction_id].
User
I think we have to use the reactions directly. Can you try getting the biomass reaction from the list and iterating over it's metabolites and adjusting their coefficients accordingly?
ChatGPT

Certainly! Here's how you can access the biomass reaction directly from the list of reactions in cobrapy and adjust the stoichiometric coefficients of its metabolites:

python

# Find the biomass reaction in the list of reactions
biomass_reaction = model.reactions.get_by_id('biomass_a')

# Adjust stoichiometric coefficients of specific metabolites in the biomass reaction
for metabolite in biomass_reaction.metabolites:
    if metabolite.id == 'atp_c':
        biomass_reaction.add_metabolites({metabolite: -(29.2 + 6.4)})
    elif metabolite.id == 'adp_c':
        biomass_reaction.add_metabolites({metabolite: 29.2 + 6.4})
    elif metabolite.id == 'pi_c':
        biomass_reaction.add_metabolites({metabolite: 29.2 + 6.4})

# Change the bounds of the 'mt' reaction
model.reactions.get_by_id('mt').lower_bound = 0
model.reactions.get_by_id('mt').upper_bound = 0

In this code:

    We use model.reactions.get_by_id('biomass_a') to directly access the biomass reaction.
    We then iterate over the metabolites associated with the biomass reaction.
    For each metabolite, we check its ID and adjust the stoichiometric coefficient accordingly.
    Finally, we change the bounds of the 'mt' reaction as in the original MATLAB script.

User
great. Now let's configure our model to use glucose + PCA for growth. Here is the matlab equivalent. Can you create the python version? 
ChatGPT

Sure, here's the Python version using cobrapy to configure the model to use glucose and PCA for growth:

python

# Set the lower bound of glucose uptake to a non-zero value
model.reactions.get_by_id('EX_glc__D_e').lower_bound = -10

# Set the lower bound of PCA uptake to a non-zero value
model.reactions.get_by_id('EX_pca_e').lower_bound = -10

# Set the objective coefficient of the biomass reaction to 1
model.reactions.get_by_id('biomass_a').objective_coefficient = 1

In this code:

    We set the lower bound of the exchange reaction for glucose uptake (EX_glc__D_e) to a non-zero value (e.g., -10), allowing the model to consume glucose.
    We set the lower bound of the exchange reaction for PCA uptake (EX_pca_e) to a non-zero value (e.g., -10), allowing the model to consume PCA.
    We set the objective coefficient of the biomass reaction (biomass_a) to 1, indicating that the model should maximize biomass production during simulation.

User
sorry, I forgot to give you the matlab code. It is a bit more complicated. See here:

M1=changeObjective(M,'biomass_a',0);% Biomasse als Optimierungsziel aus
M1=changeObjective(M1,'EX_glc_e',1);% Glucose Uptake als Opt-Ziel an
M1=changeRxnBounds(M1,'EX_glc_e',-30,'l');% Glucose Uptake ermöglichen Lower bound =30
M1=changeRxnBounds(M1,'EX_glc_e',30,'u');% Glucose Uptake ermöglichen Upper bound =30

% Messwerte Wachstumsraten auf Glucose+PCA als C-Quelle
% M1=changeRxnBounds(M1,'biomass_a',0.6,'b');
% M1=changeRxnBounds(M1,'biomass_a',0.493689,'b');
% M1=changeRxnBounds(M1,'biomass_a',0.522519,'b');

% Wachstumsrate festsetzen auf [0.493;0.523]
M1=changeRxnBounds(M1,'biomass_a',0.493,'l');
M1=changeRxnBounds(M1,'biomass_a',0.523,'u');
M1=changeRxnBounds(M1,'EX_pca',-1.1,'b');% PCA Uptake festsetzen auf 1.1
% FBA
[fluxMapM1,SolM1, ~]=quickSolveFBA(M1, true); 
% Kleine Flüsse auf Null runden
for i=1:r, if(abs(fluxMapM1(i))<0.00001),fluxMapM1(i)=0;end, end
length(find(fluxMapM1~=0))
% Indizes für FLüsse über Systemgrenze raus suchen 
n=1;
for i=1:r
    if(sum(abs(M0.S(:,i)))==1)
        ex(n)=i;n=n+1;
    end
end
% Flüsse über Systemgrenze (Bezeichnung + Wert) in Variable ausgeben
n=1;
for i=1:length(ex)
    if(fluxMapM1(ex(i))~=0)
        EX1{n,1}=M1.rxns(ex(i));EX1{n,2}=fluxMapM1(ex(i));
        n=n+1;
    end
end
ChatGPT

Got it! Here's the Python equivalent of the provided MATLAB code:

python

# Set the objective to glucose uptake and allow glucose uptake
M1 = M.copy()
M1.objective = 'EX_glc__D_e'
M1.reactions.get_by_id('EX_glc__D_e').lower_bound = -30
M1.reactions.get_by_id('EX_glc__D_e').upper_bound = 30

# Set the growth rate bounds on glucose + PCA as carbon source
M1.reactions.get_by_id('biomass_a').lower_bound = 0.493
M1.reactions.get_by_id('biomass_a').upper_bound = 0.523

# Set PCA uptake to 1.1
M1.reactions.get_by_id('EX_pca_e').lower_bound = -1.1

# Perform Flux Balance Analysis (FBA)
solution = M1.optimize()

# Round small fluxes to zero
for reaction in solution.fluxes.index:
    if abs(solution.fluxes[reaction]) < 0.00001:
        solution.fluxes[reaction] = 0

# Find indices of fluxes over the system boundary
ex = []
for i, reaction in enumerate(M1.reactions):
    if sum(abs(reaction.metabolites[metabolite]) == 1 for metabolite in reaction.metabolites) == 1:
        ex.append(i)

# Get fluxes over the system boundary
EX1 = []
for i in ex:
    if solution.fluxes[i] != 0:
        EX1.append((M1.reactions[i].id, solution.fluxes[i]))

This Python code performs the same operations as the provided MATLAB code:

    Sets the objective to glucose uptake, allows glucose uptake within bounds, and sets growth rate bounds on glucose + PCA as carbon source.
    Sets PCA uptake to 1.1.
    Performs Flux Balance Analysis (FBA) and rounds small fluxes to zero.
    Finds fluxes over the system boundary and gets their values.

User
actually my Model in python is called model. Can you also rename M1 to model_PCA_gluc?
ChatGPT

Of course! Here's the adjusted Python code:

python

# Set the objective to glucose uptake and allow glucose uptake
model_PCA_gluc = model.copy()
model_PCA_gluc.objective = 'EX_glc__D_e'
model_PCA_gluc.reactions.get_by_id('EX_glc__D_e').lower_bound = -30
model_PCA_gluc.reactions.get_by_id('EX_glc__D_e').upper_bound = 30

# Set the growth rate bounds on glucose + PCA as carbon source
model_PCA_gluc.reactions.get_by_id('biomass_a').lower_bound = 0.493
model_PCA_gluc.reactions.get_by_id('biomass_a').upper_bound = 0.523

# Set PCA uptake to 1.1
model_PCA_gluc.reactions.get_by_id('EX_pca_e').lower_bound = -1.1

# Perform Flux Balance Analysis (FBA)
solution = model_PCA_gluc.optimize()

# Round small fluxes to zero
for reaction in solution.fluxes.index:
    if abs(solution.fluxes[reaction]) < 0.00001:
        solution.fluxes[reaction] = 0

# Find indices of fluxes over the system boundary
ex = []
for i, reaction in enumerate(model_PCA_gluc.reactions):
    if sum(abs(reaction.metabolites[metabolite]) == 1 for metabolite in reaction.metabolites) == 1:
        ex.append(i)

# Get fluxes over the system boundary
EX1 = []
for i in ex:
    if solution.fluxes[i] != 0:
        EX1.append((model_PCA_gluc.reactions[i].id, solution.fluxes[i]))

I replaced M1 with model_PCA_gluc as per your request, and the code should function identically.
User
so far so good, however it seem the api for FBA has changes. Do you happen to know of any other way to call FBA using cobrapy?
ChatGPT

Certainly! The method for performing Flux Balance Analysis (FBA) in cobrapy has indeed changed slightly. Instead of using the optimize() method directly on the model object, you can now use the pFBA method to perform FBA. This method calculates a flux distribution that maximizes the overall flux while simultaneously minimizing the sum of absolute fluxes. Here's how you can use it:

python

from cobra.flux_analysis import pfba

# Perform pFBA
solution = pfba(model_PCA_gluc)

# Round small fluxes to zero
for reaction in solution.fluxes.index:
    if abs(solution.fluxes[reaction]) < 0.00001:
        solution.fluxes[reaction] = 0

# Find indices of fluxes over the system boundary
ex = []
for i, reaction in enumerate(model_PCA_gluc.reactions):
    if sum(abs(reaction.metabolites[metabolite]) == 1 for metabolite in reaction.metabolites) == 1:
        ex.append(i)

# Get fluxes over the system boundary
EX1 = []
for i in ex:
    if solution.fluxes[i] != 0:
        EX1.append((model_PCA_gluc.reactions[i].id, solution.fluxes[i]))

In this code:

    We use pfba() function from cobra.flux_analysis module to perform pFBA.
    We then continue with the same post-processing steps as before.

This way, you can perform FBA using the latest cobrapy API.
User
what is pFBA
ChatGPT

pFBA stands for Parsimonious Flux Balance Analysis. It's a method used in constraint-based modeling to find a flux distribution that maximizes a given objective (such as biomass production) while minimizing the total sum of fluxes in the network.

In pFBA, the optimization problem is formulated as follows:

r

Maximize:  c^T * v
Subject to:
            S * v = 0    (mass balance constraints)
            lb <= v <= ub   (flux bounds constraints)

where:

    c is the objective coefficient vector.
    v is the vector of reaction fluxes.
    S is the stoichiometric matrix.
    lb and ub are lower and upper bounds on reaction fluxes.

The objective of pFBA is to find a flux distribution that optimizes the objective function (usually maximizing biomass production) while keeping the total sum of fluxes as low as possible, thus favoring more parsimonious solutions.

In practice, pFBA is often used in cases where there are multiple potential optimal solutions or when looking for a solution that is more biologically plausible. It's a popular method for performing flux balance analysis in constraint-based metabolic modeling.
2 / 2
User
pFBA sounds nice. To understand the biological difference, I also need the modern API for regular FBA
ChatGPT

Certainly! For performing regular Flux Balance Analysis (FBA) in cobrapy, you can use the optimize() method directly on the model object. Here's how you can use it:

python

# Perform FBA
solution = model_PCA_gluc.optimize()

# Round small fluxes to zero
for reaction in solution.fluxes.index:
    if abs(solution.fluxes[reaction]) < 0.00001:
        solution.fluxes[reaction] = 0

# Find indices of fluxes over the system boundary
ex = []
for i, reaction in enumerate(model_PCA_gluc.reactions):
    if sum(abs(reaction.metabolites[metabolite]) == 1 for metabolite in reaction.metabolites) == 1:
        ex.append(i)

# Get fluxes over the system boundary
EX1 = []
for i in ex:
    if solution.fluxes[i] != 0:
        EX1.append((model_PCA_gluc.reactions[i].id, solution.fluxes[i]))

In this code:

    We use the optimize() method on the model_PCA_gluc object to perform regular FBA.
    We continue with the same post-processing steps as before to round small fluxes to zero and find fluxes over the system boundary.

This way, you can perform regular FBA using cobrapy's classic optimization method.
User
do you have an idea why the parsimonious fba problem could be infeasible, while the regular fba problem has a solution?
ChatGPT

Yes, there are several reasons why a parsimonious Flux Balance Analysis (pFBA) problem might be infeasible while the regular FBA problem has a solution:

    Objective Function Differences: In pFBA, the objective is to minimize the total sum of fluxes while maximizing a given objective function (e.g., biomass production). This dual objective might lead to infeasibility if there are conflicting requirements in the network. In contrast, regular FBA focuses solely on maximizing the objective function, which might have more feasible solutions.

    Tight Constraints: The parsimonious nature of pFBA may lead to tighter constraints on the solution space compared to regular FBA. If the model has highly constrained or conflicting reactions, it might result in an infeasible pFBA solution even though regular FBA finds a feasible solution.

    Network Structure: The structure of the metabolic network can affect the feasibility of pFBA versus regular FBA solutions. If the network contains dead-end metabolites or blocked reactions that cannot carry flux under certain conditions, it might cause infeasibility in pFBA while regular FBA might still find a solution.

    Solution Space Exploration: pFBA explores the entire solution space to find a parsimonious solution, which might uncover infeasibilities that regular FBA overlooks. Regular FBA, on the other hand, focuses on finding a single optimal solution, which might ignore certain constraints that lead to infeasibility.

    Implementation Issues: In some cases, infeasibility in pFBA might be due to implementation issues such as numerical instabilities or algorithmic limitations. Regular FBA might be more robust to such issues due to its simpler optimization problem.

Overall, the differences in problem formulation, solution space exploration, and network constraints can lead to situations where pFBA is infeasible while regular FBA has a solution.
User
I would like to store our chat history. Is it possible?
ChatGPT

I don't have the capability to directly store chat history or access previous conversations. However, you can manually save the chat history by copying the conversation and pasting it into a text file, document, or any other format you prefer. If you have any specific questions or topics you'd like to revisit in the future, feel free to ask, and I'll do my best to assist you!

